Objetivo: buscar el mejor algoritmo de ordenamiento
Como mínimo se deben comparar:
	- Insertion Sort
	- Merge Sort
	- Quick Sort
	- Heap Sort
	- Introsort (STL)
	- Un algoritmo extra (de comparación)

Notas:
	- Los experimentos se hacen con archivos serializados (Binarios con 32 bits)
	- Los experimentos se deben realizar al menos 20 veces.


Explicación de todo para ejecutar:

-------------- o ------------------------------------------------------------------------------------
main.cpp: el main recibe 3 argumentos: el nombre del archivo (binario) a leer, el tipo de algoritmo de ordenamiento a usar y
las subparticiones del archivo (o sea separar el archivo en arreglos de tamaño N donde se testean cada uno)
¡Si es que el tercer argumento es vacío se considerará todo el archivo como un solo arreglo!

Explicaciones del código:
int arraySize: tamaño de los subarreglos, si es que el valor es 0 significa que tomaremos todo como un solo arreglo.
std::ifstream input: Objeto que permite leer datos desde un archivo (Es como el FILE* de C)
std::vector<int32_t> array: necesitamos asegurarnos de que los tamaños porque el tamaño de int varía según plataforma
double sumtime: suma de tiempo que se tardaron todos los subarreglos en ejecutarse

para compilar: g++ sorts/heap.cpp sorts/quicksort.cpp main.cpp -o a
argumentos: ./a (archivo a leer) (x) (OPCIONAL: tamaño de cada arreglo)

x = (0: HeapSort, 1: QuickSort, 2: Sort (STL), 3: RandomizedQuickSort, 4: InsertionSort, 5: MergeSort, 6: MergeInsertionSort)

Si no se pone el tercer argumento, te va a devolver el tiempo que tardó en ordenar todo el archivo.
Por otro lado, si colocas tercer argumento, te dirá el tiempo que tardó cada arreglo en ordenarse.

-------------- o ------------------------------------------------------------------------------------
randomNumbersGeneratorBinary.cpp: genera números que pueden ser aleatorios, ordenados, etc y los guarda en un archivo
argumentos: ./c (x) (cantidad de arreglos) (tamaño de cada arreglo) (rango de números de generación) (archivo a guardar)

x = (0: aleatorios, 1: ordenados ascendente, 2: ordenados descendente, 3: todos iguales, 4: mitad ordenada mitad random, 5: mitad random mitad ordenada)
-------------- o ------------------------------------------------------------------------------------


Explicación uso desviación esstandar para 
